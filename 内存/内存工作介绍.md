
**虚拟地址空间的内部又被分为内核空间和用户空间两部分:**  
<img src="https://github.com/Yongli-Lisa/Linux-performance-optimization/blob/4a9f5c8081272e4447bcf509c6eae42848ffea70/Img/%E5%86%85%E5%AD%98/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4.PNG" width="400px">  


**内存映射**，将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系:  
(页表实际上存储在 CPU 的内存管理单元 MMU 中，这样，正常情况下，处理器就可以直接通过硬件，找出要访问的内存。当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。TLB 是 MMU 中页表的高速缓存。)  
<img src="https://github.com/Yongli-Lisa/Linux-performance-optimization/blob/4a9f5c8081272e4447bcf509c6eae42848ffea70/Img/%E5%86%85%E5%AD%98/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.PNG" width="300px">  


MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB 整数倍的内存空间。  
页的大小只有 4 KB ，导致的另一个问题就是，整个页表会变得非常大。为了解决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）。  
多级页表(虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移。):  
<img src="https://github.com/Yongli-Lisa/Linux-performance-optimization/blob/4a9f5c8081272e4447bcf509c6eae42848ffea70/Img/%E5%86%85%E5%AD%98/%E5%9B%9B%E7%BA%A7%E9%A1%B5%E8%A1%A8.PNG" width="300px">  
大页，是比普通页更大的内存块，常见的大小有 2MB 和 1GB。大页通常用在使用大量内存的进程上，比如 Oracle、DPDK 等。  

**虚拟内存空间分布:**  
1. 只读段，包括代码和常量等。
2. 数据段，包括全局变量等。
3. 堆，包括动态分配的内存，从低地址开始向上增长。
4. 文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
5. 栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。  
<img src="https://github.com/Yongli-Lisa/Linux-performance-optimization/blob/4a9f5c8081272e4447bcf509c6eae42848ffea70/Img/%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.PNG" width="600px">  


**内存分配与回收:**  
malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。   
对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。   
在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 则通过 slab 分配器来管理小内存。你可以把 slab 看成构建在伙伴系统上的一个缓存，主要作用就是分配并释放内核中的小对象。  
而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。  

对内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用 free() 或 unmap() ，来释放这些不用的内存。  

内存回收方式：  
1. 回收缓存，比如使用 LRU（Least Recently Used）算法，
2. 回收最近使用最少的内存页面； 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；会用到交换分区（Swap）   
3. 杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。(OOM)

OOM是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：  
一个进程消耗的内存越大，oom_score 就越大； 
一个进程运行占用的 CPU 越多，oom_score 就越小。  
进程的 oom_score 越大，代表消耗的内存越多，也就越容易被 OOM 杀死  
为了实际工作的需要，管理员可以通过 /proc 文件系统，手动设置进程的 oom_adj ，从而调整进程的 oom_score。 oom_adj 的范围是 [-17, 15]，数值越大，表示进程越容易被 OOM 杀死；数值越小，表示进程越不容易被 OOM 杀死，其中 -17 表示禁止 OOM。  

**查看内存使用情况：**    
```
# 注意不同版本的free输出可能会有所不同
$ free
              total        used        free      shared  buff/cache   available
Mem:        8169348      263524     6875352         668     1030472     7611064
Swap:             0           0           0
```  
第一列，total 是总内存大小；   
第二列，used 是已使用内存的大小，包含了共享内存；   
第三列，free 是未使用内存的大小；   
第四列，shared 是共享内存的大小；   
第五列，buff/cache 是缓存和缓冲区的大小；   
最后一列，available 是新进程可用内存的大小。


free 显示的是整个系统的内存使用情况。如果你想查看进程的内存使用情况，可以用 top 或者 ps 等工具。  
```
# 按下M切换到内存排序
$ top
...
KiB Mem :  8169348 total,  6871440 free,   267096 used,  1030812 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  7607492 avail Mem


  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
  430 root      19  -1  122360  35588  23748 S   0.0  0.4   0:32.17 systemd-journal
 1075 root      20   0  771860  22744  11368 S   0.0  0.3   0:38.89 snapd
 1048 root      20   0  170904  17292   9488 S   0.0  0.2   0:00.24 networkd-dispat
    1 root      20   0   78020   9156   6644 S   0.0  0.1   0:22.92 systemd
12376 azure     20   0   76632   7456   6420 S   0.0  0.1   0:00.01 systemd
12374 root      20   0  107984   7312   6304 S   0.0  0.1   0:00.00 sshd
...
```
VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。  
RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。  
SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。  


 
